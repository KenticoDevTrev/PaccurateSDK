/* 
 * paccurate.io
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.4.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// Pack
    /// </summary>
    [DataContract]
    public partial class Pack :  IEquatable<Pack>, IValidatableObject
    {
        /// <summary>
        /// template name for markup generation.
        /// </summary>
        /// <value>template name for markup generation.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum TemplateEnum
        {
            
            /// <summary>
            /// Enum DemoTmpl for value: demo.tmpl
            /// </summary>
            [EnumMember(Value = "demo.tmpl")]
            DemoTmpl = 1,
            
            /// <summary>
            /// Enum ShipappTmpl for value: shipapp.tmpl
            /// </summary>
            [EnumMember(Value = "shipapp.tmpl")]
            ShipappTmpl = 2,
            
            /// <summary>
            /// Enum BoatTmpl for value: boat.tmpl
            /// </summary>
            [EnumMember(Value = "boat.tmpl")]
            BoatTmpl = 3
        }

        /// <summary>
        /// template name for markup generation.
        /// </summary>
        /// <value>template name for markup generation.</value>
        [DataMember(Name="template", EmitDefaultValue=false)]
        public TemplateEnum? Template { get; set; }
        /// <summary>
        /// case-insensitive format to render images in, either &#39;SVG&#39; or &#39;PNG&#39;, if includeImages is enabled.
        /// </summary>
        /// <value>case-insensitive format to render images in, either &#39;SVG&#39; or &#39;PNG&#39;, if includeImages is enabled.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ImageFormatEnum
        {
            
            /// <summary>
            /// Enum Svg for value: svg
            /// </summary>
            [EnumMember(Value = "svg")]
            Svg = 1,
            
            /// <summary>
            /// Enum Png for value: png
            /// </summary>
            [EnumMember(Value = "png")]
            Png = 2
        }

        /// <summary>
        /// case-insensitive format to render images in, either &#39;SVG&#39; or &#39;PNG&#39;, if includeImages is enabled.
        /// </summary>
        /// <value>case-insensitive format to render images in, either &#39;SVG&#39; or &#39;PNG&#39;, if includeImages is enabled.</value>
        [DataMember(Name="imageFormat", EmitDefaultValue=false)]
        public ImageFormatEnum? ImageFormat { get; set; }
        /// <summary>
        /// How to place items. &#39;default&#39; will defer to coordOrder, &#39;corner&#39; minimizes distance to rear, bottom corner, &#39;wedge&#39; minimizes distance to middle of bottom, back edge, &#39;mound&#39; minimizes distance to center of carton bottom.
        /// </summary>
        /// <value>How to place items. &#39;default&#39; will defer to coordOrder, &#39;corner&#39; minimizes distance to rear, bottom corner, &#39;wedge&#39; minimizes distance to middle of bottom, back edge, &#39;mound&#39; minimizes distance to center of carton bottom.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum PlacementStyleEnum
        {
            
            /// <summary>
            /// Enum Default for value: default
            /// </summary>
            [EnumMember(Value = "default")]
            Default = 1,
            
            /// <summary>
            /// Enum Corner for value: corner
            /// </summary>
            [EnumMember(Value = "corner")]
            Corner = 2,
            
            /// <summary>
            /// Enum Wedge for value: wedge
            /// </summary>
            [EnumMember(Value = "wedge")]
            Wedge = 3,
            
            /// <summary>
            /// Enum Mound for value: mound
            /// </summary>
            [EnumMember(Value = "mound")]
            Mound = 4,
            
            /// <summary>
            /// Enum Orb for value: orb
            /// </summary>
            [EnumMember(Value = "orb")]
            Orb = 5
        }

        /// <summary>
        /// How to place items. &#39;default&#39; will defer to coordOrder, &#39;corner&#39; minimizes distance to rear, bottom corner, &#39;wedge&#39; minimizes distance to middle of bottom, back edge, &#39;mound&#39; minimizes distance to center of carton bottom.
        /// </summary>
        /// <value>How to place items. &#39;default&#39; will defer to coordOrder, &#39;corner&#39; minimizes distance to rear, bottom corner, &#39;wedge&#39; minimizes distance to middle of bottom, back edge, &#39;mound&#39; minimizes distance to center of carton bottom.</value>
        [DataMember(Name="placementStyle", EmitDefaultValue=false)]
        public PlacementStyleEnum? PlacementStyle { get; set; }
        /// <summary>
        /// Method to use to sort items for placement. Default is item volume descending. &#39;largest-box-needed&#39; is by the volume of the smallest box type specified that will fit the item, descending, &#39;largest-girth&#39; is 2*(width + height), descending, &#39;longest-dimension&#39; is by longest single item dimension, descending, &#39;largest-cross-section&#39; is by largest product of the two greatest dimensions, descending. It can often be worth attempting packs with competing itemSorts and picking the lowest cost option. &#39;combined&#39; uses all possible item sorts and returns the lowest totalCost option.
        /// </summary>
        /// <value>Method to use to sort items for placement. Default is item volume descending. &#39;largest-box-needed&#39; is by the volume of the smallest box type specified that will fit the item, descending, &#39;largest-girth&#39; is 2*(width + height), descending, &#39;longest-dimension&#39; is by longest single item dimension, descending, &#39;largest-cross-section&#39; is by largest product of the two greatest dimensions, descending. It can often be worth attempting packs with competing itemSorts and picking the lowest cost option. &#39;combined&#39; uses all possible item sorts and returns the lowest totalCost option.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ItemSortEnum
        {
            
            /// <summary>
            /// Enum Default for value: default
            /// </summary>
            [EnumMember(Value = "default")]
            Default = 1,
            
            /// <summary>
            /// Enum LargestBoxNeeded for value: largest-box-needed
            /// </summary>
            [EnumMember(Value = "largest-box-needed")]
            LargestBoxNeeded = 2,
            
            /// <summary>
            /// Enum LargestGirth for value: largest-girth
            /// </summary>
            [EnumMember(Value = "largest-girth")]
            LargestGirth = 3,
            
            /// <summary>
            /// Enum LargestLengthPlusGirth for value: largest-length-plus-girth
            /// </summary>
            [EnumMember(Value = "largest-length-plus-girth")]
            LargestLengthPlusGirth = 4,
            
            /// <summary>
            /// Enum LongestDimension for value: longest-dimension
            /// </summary>
            [EnumMember(Value = "longest-dimension")]
            LongestDimension = 5,
            
            /// <summary>
            /// Enum LargestCrossSection for value: largest-cross-section
            /// </summary>
            [EnumMember(Value = "largest-cross-section")]
            LargestCrossSection = 6,
            
            /// <summary>
            /// Enum Combined for value: combined
            /// </summary>
            [EnumMember(Value = "combined")]
            Combined = 7
        }

        /// <summary>
        /// Method to use to sort items for placement. Default is item volume descending. &#39;largest-box-needed&#39; is by the volume of the smallest box type specified that will fit the item, descending, &#39;largest-girth&#39; is 2*(width + height), descending, &#39;longest-dimension&#39; is by longest single item dimension, descending, &#39;largest-cross-section&#39; is by largest product of the two greatest dimensions, descending. It can often be worth attempting packs with competing itemSorts and picking the lowest cost option. &#39;combined&#39; uses all possible item sorts and returns the lowest totalCost option.
        /// </summary>
        /// <value>Method to use to sort items for placement. Default is item volume descending. &#39;largest-box-needed&#39; is by the volume of the smallest box type specified that will fit the item, descending, &#39;largest-girth&#39; is 2*(width + height), descending, &#39;longest-dimension&#39; is by longest single item dimension, descending, &#39;largest-cross-section&#39; is by largest product of the two greatest dimensions, descending. It can often be worth attempting packs with competing itemSorts and picking the lowest cost option. &#39;combined&#39; uses all possible item sorts and returns the lowest totalCost option.</value>
        [DataMember(Name="itemSort", EmitDefaultValue=false)]
        public ItemSortEnum? ItemSort { get; set; }
        /// <summary>
        /// Defines how available boxTypes are selected when a new box must be created to pack additional items. The &#39;estimated&#39; style uses &#39;usableSpace&#39; to estimate how quickly each valid boxType will be filled by both weight and volume, and estimated cost is calculated. &#39;actual&#39; attempts real placement of subsequent items in each available boxType and selects the one with the lowest actual cost. &#39;actual&#39; is much slower than &#39;estimated&#39;, but will often return superior cost optimizations.
        /// </summary>
        /// <value>Defines how available boxTypes are selected when a new box must be created to pack additional items. The &#39;estimated&#39; style uses &#39;usableSpace&#39; to estimate how quickly each valid boxType will be filled by both weight and volume, and estimated cost is calculated. &#39;actual&#39; attempts real placement of subsequent items in each available boxType and selects the one with the lowest actual cost. &#39;actual&#39; is much slower than &#39;estimated&#39;, but will often return superior cost optimizations.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum BoxTypeChoiceStyleEnum
        {
            
            /// <summary>
            /// Enum Actual for value: actual
            /// </summary>
            [EnumMember(Value = "actual")]
            Actual = 1,
            
            /// <summary>
            /// Enum Estimated for value: estimated
            /// </summary>
            [EnumMember(Value = "estimated")]
            Estimated = 2
        }

        /// <summary>
        /// Defines how available boxTypes are selected when a new box must be created to pack additional items. The &#39;estimated&#39; style uses &#39;usableSpace&#39; to estimate how quickly each valid boxType will be filled by both weight and volume, and estimated cost is calculated. &#39;actual&#39; attempts real placement of subsequent items in each available boxType and selects the one with the lowest actual cost. &#39;actual&#39; is much slower than &#39;estimated&#39;, but will often return superior cost optimizations.
        /// </summary>
        /// <value>Defines how available boxTypes are selected when a new box must be created to pack additional items. The &#39;estimated&#39; style uses &#39;usableSpace&#39; to estimate how quickly each valid boxType will be filled by both weight and volume, and estimated cost is calculated. &#39;actual&#39; attempts real placement of subsequent items in each available boxType and selects the one with the lowest actual cost. &#39;actual&#39; is much slower than &#39;estimated&#39;, but will often return superior cost optimizations.</value>
        [DataMember(Name="boxTypeChoiceStyle", EmitDefaultValue=false)]
        public BoxTypeChoiceStyleEnum? BoxTypeChoiceStyle { get; set; }
        /// <summary>
        /// The objective to evaluate boxTypeChoices by. &#39;lowest-cost&#39; minimizes price or volume cost of boxTypes selected, &#39;most-items&#39; maximizes item count per box opened, i.e., fewest total boxes used.
        /// </summary>
        /// <value>The objective to evaluate boxTypeChoices by. &#39;lowest-cost&#39; minimizes price or volume cost of boxTypes selected, &#39;most-items&#39; maximizes item count per box opened, i.e., fewest total boxes used.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum BoxTypeChoiceGoalEnum
        {
            
            /// <summary>
            /// Enum LowestCost for value: lowest-cost
            /// </summary>
            [EnumMember(Value = "lowest-cost")]
            LowestCost = 1,
            
            /// <summary>
            /// Enum MostItems for value: most-items
            /// </summary>
            [EnumMember(Value = "most-items")]
            MostItems = 2
        }

        /// <summary>
        /// The objective to evaluate boxTypeChoices by. &#39;lowest-cost&#39; minimizes price or volume cost of boxTypes selected, &#39;most-items&#39; maximizes item count per box opened, i.e., fewest total boxes used.
        /// </summary>
        /// <value>The objective to evaluate boxTypeChoices by. &#39;lowest-cost&#39; minimizes price or volume cost of boxTypes selected, &#39;most-items&#39; maximizes item count per box opened, i.e., fewest total boxes used.</value>
        [DataMember(Name="boxTypeChoiceGoal", EmitDefaultValue=false)]
        public BoxTypeChoiceGoalEnum? BoxTypeChoiceGoal { get; set; }
        /// <summary>
        /// The tiebreaker to use in the event to box type choices are otherwise completely equal. Default is \&quot;volume\&quot;, alternative is \&quot;weight\&quot;.
        /// </summary>
        /// <value>The tiebreaker to use in the event to box type choices are otherwise completely equal. Default is \&quot;volume\&quot;, alternative is \&quot;weight\&quot;.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ValueTiebreakerEnum
        {
            
            /// <summary>
            /// Enum Volume for value: volume
            /// </summary>
            [EnumMember(Value = "volume")]
            Volume = 1,
            
            /// <summary>
            /// Enum Weight for value: weight
            /// </summary>
            [EnumMember(Value = "weight")]
            Weight = 2
        }

        /// <summary>
        /// The tiebreaker to use in the event to box type choices are otherwise completely equal. Default is \&quot;volume\&quot;, alternative is \&quot;weight\&quot;.
        /// </summary>
        /// <value>The tiebreaker to use in the event to box type choices are otherwise completely equal. Default is \&quot;volume\&quot;, alternative is \&quot;weight\&quot;.</value>
        [DataMember(Name="valueTiebreaker", EmitDefaultValue=false)]
        public ValueTiebreakerEnum? ValueTiebreaker { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Pack" /> class.
        /// </summary>
        /// <param name="key">issued API key..</param>
        /// <param name="layFlat">aligns all items laying flat. If possible, it may create a \&quot;brick-laying\&quot; pattern to increase stability. (default to false).</param>
        /// <param name="interlock">alternates layFlat orientation by layer, so as to create an interlocked placement pattern and improve item stability. (default to false).</param>
        /// <param name="corners">only pack items at valid corner points of other items (optimal) (default to true).</param>
        /// <param name="itemSets">item set definitions if not creating random items..</param>
        /// <param name="boxTypes">box type definitions for packing, will override boxTypeSets defined..</param>
        /// <param name="boxes">pre-packed boxes, including any items specified that will be packed and excess space used before any new boxes are created..</param>
        /// <param name="usableSpace">an estimate of typical box utilization for the quick \&quot;estimated\&quot; boxTypeChoiceStyle, which will be used to ensure \&quot;estimated\&quot; box type choices are not overly optimistic regarding potential volume utilization..</param>
        /// <param name="reservedSpace">space in boxes that is reserved, i.e., for packing material..</param>
        /// <param name="boxTypeSets">predefined box types to be used, separated by commas. Will be overridden by boxTypes. Acceptable values are &lt;ul&gt;&lt;li&gt;\&quot;fedex\&quot;- -FedEx OneRate&lt;/li&gt;&lt;li&gt;\&quot;usps\&quot;- -USPS Priority Flat Rate&lt;/li&gt;&lt;li&gt;\&quot;pallet\&quot;- -full-, half-, and quarter-sized 48\&quot;x40\&quot; pallets..</param>
        /// <param name="eye">The x,y,z coordinates of the virtual eye looking at the package for visualization purposes. Default is isometric, \&quot;1,1,1\&quot;. To generate a side view, one could use \&quot;0.001,1.0,0.001\&quot;..</param>
        /// <param name="packOrigin">the x,y,z coordinates of an optional packing origin. A packing origin is used to create more balanced packing for situations where load needs to be considered. E.g., for a 40\&quot;x48\&quot; pallet, a packOrigin representing the middle of the pallet, \&quot;0,20,24\&quot;, would cause placement to minimize the distance of the packed items from the center of the pallet..</param>
        /// <param name="zone">&lt;b&gt;[experimental]&lt;/b&gt; the shipping zone in order to use basic zone-based price optimization..</param>
        /// <param name="rules">Array of packing rules..</param>
        /// <param name="random">create random items (default to false).</param>
        /// <param name="n">number of random items to generate and the quantity of each if \&quot;random\&quot; is set to true. a value of 5 would create 5 different items with a quantity of 5 each, making the total item quantity equal to n&amp;sup2;.</param>
        /// <param name="randomMaxDimension">maximum item dimension along a single axis for randomly generated items..</param>
        /// <param name="randomMaxWeight">maximum item weight for randomly generated items..</param>
        /// <param name="randomMaxQuantity">maximum quantity for randomly generated items..</param>
        /// <param name="seed">if random is selected, seed the random number generator to deterministically generate random items to pack. (default to true).</param>
        /// <param name="seedValue">if seed is set to true, specifies a non-default seed for the random number generator..</param>
        /// <param name="imgSize">width of rendered SVGs in pixels..</param>
        /// <param name="template">template name for markup generation..</param>
        /// <param name="includeScripts">include inline javascripts and styles for base template (default to true).</param>
        /// <param name="includeImages">include inline images, default is always on (default to true).</param>
        /// <param name="imageFormat">case-insensitive format to render images in, either &#39;SVG&#39; or &#39;PNG&#39;, if includeImages is enabled. (default to ImageFormatEnum.Svg).</param>
        /// <param name="coordOrder">If placementStyle is set to \&quot;default\&quot;, coordOrder sets the placement priority of axes ascendingly. \&quot;0,1,2\&quot; would search for placement points along the Z(length,\&quot;2\&quot;), then Y(width,\&quot;1\&quot;), and finally X(height\&quot;0\&quot;). Keep in mind that in the default rendering the \&quot;up\&quot; direction is X and the other axes follow the right-hand rule. This is useful for different packing methods. E.g., Utilizing \&quot;2,0,1\&quot; would pack a shipping container first in the Y(width) direction, then in the X(height) direction, and finally in the Z(length) direction, replication a floor-to-ceiling, front-to-back loading method..</param>
        /// <param name="cohortPacking">if selected, will ensure that all like items will be packed together, in no more than [cohortMax] different groups within a single container. (default to false).</param>
        /// <param name="cohortMax">the maximum number of contiguous cohorts for a given item type within a single container. E.g., if you pack 40 chairs in a single container, a cohortMax of 2 could yield one (all 40 chairs in a single block if space is availabe) or two (say, 25 chairs in one corner and 15 in the other) contiguous cohorts..</param>
        /// <param name="allowableOverhang">The amount an item can overhang lower items that it is placed upon. The units are whatever units the box and item dimensions are given in. By convention, inches..</param>
        /// <param name="placementStyle">How to place items. &#39;default&#39; will defer to coordOrder, &#39;corner&#39; minimizes distance to rear, bottom corner, &#39;wedge&#39; minimizes distance to middle of bottom, back edge, &#39;mound&#39; minimizes distance to center of carton bottom. (default to PlacementStyleEnum.Default).</param>
        /// <param name="itemSort">Method to use to sort items for placement. Default is item volume descending. &#39;largest-box-needed&#39; is by the volume of the smallest box type specified that will fit the item, descending, &#39;largest-girth&#39; is 2*(width + height), descending, &#39;longest-dimension&#39; is by longest single item dimension, descending, &#39;largest-cross-section&#39; is by largest product of the two greatest dimensions, descending. It can often be worth attempting packs with competing itemSorts and picking the lowest cost option. &#39;combined&#39; uses all possible item sorts and returns the lowest totalCost option. (default to ItemSortEnum.Combined).</param>
        /// <param name="itemSortReverse">Whether or not to reverse the itemSort utilized. (default to false).</param>
        /// <param name="itemInitialOrientationBestForBox">For all items where orientation flipping is used, the orientation producing the highest multiple of items fit per remaining dimension is used as the first orientation. This option should be enabled when packing high quantities of single item types, but may produce inconsistent results in other cases. Defers to item orientation locking and itemOrientationSearchDepth &gt; 0 if a superior result is found. (default to false).</param>
        /// <param name="itemInitialOrientationPreferred">Whether to attempt packing by either greedily placing items or placing all allowable combinations of initial item orientations and selecting the most performant. When true, items will be placed immediately using the orientation reflected by their dimensions definition and will only be flipped if a placement cannot be found and the item rules allow orientation changes. When false, all allowable initial orientation combinations will be attempted for each item in each box. (default to true).</param>
        /// <param name="itemOrientationSearchDepth">When itemInitialOrientationPreferred is set to false, the itemOrientationSearchDepth is the number of unique, sorted, groups of Items sharing the same ItemSet definition that will be have every combination of initial orientation attempted. A value of 1 signifies that only the first item (and others still unpacked from its ItemSet) will have every orientation attempted and the engine subsequently selecting the most performant. A value of 2 signifies that the first groups of unpacked items, each sharing an ItemSet, will have every combination of orientation attempted. Increasing this value from 1 can very rapidly result in excessive complexity and a timeout error instead of a result, so discretion is advised..</param>
        /// <param name="sequenceSort">Whether or not the items should be initially sorted by their sequence value instead of by the specified itemSort. This is not always useful, as the default \&quot;biggest-first\&quot; volume sort is very effective for items, and constraining by maxSequenceDistance is applied regardless of this field. That said, for doing custom pre-sorts such as weight-based instead of volume based, this value should be set to true. (default to false).</param>
        /// <param name="sequenceHeatMap">Colorize items solely by their sequence value, light when sequence is high, dark when it is low. Useful for indicating item bin location, weight, or other sequence property that may not be apparent from the default visualization. (default to false).</param>
        /// <param name="maxSequenceDistance">This is the maximum distance allowable between two sequence values of items packed in a common box. E.g., \&quot;Distance\&quot; for an item sequence composed of aisle/bin combinations of \&quot;0401\&quot; and \&quot;1228\&quot; has a sequence distance of \\|1228 - 401\\| &#x3D; 827.</param>
        /// <param name="boxTypeChoiceStyle">Defines how available boxTypes are selected when a new box must be created to pack additional items. The &#39;estimated&#39; style uses &#39;usableSpace&#39; to estimate how quickly each valid boxType will be filled by both weight and volume, and estimated cost is calculated. &#39;actual&#39; attempts real placement of subsequent items in each available boxType and selects the one with the lowest actual cost. &#39;actual&#39; is much slower than &#39;estimated&#39;, but will often return superior cost optimizations. (default to BoxTypeChoiceStyleEnum.Actual).</param>
        /// <param name="boxTypeChoiceLookahead">&lt;p&gt;When selecting the next available boxType, we must consider how far to look ahead.&lt;/p&gt;&lt;p&gt;Consider we have 8 items of identical dimensions, and two flat rate boxTypes. It is found that Box A can fit 6 items, and costs $12. Box B can fit 4 items, and costs $10.&lt;/p&gt;&lt;p&gt;If we consider only the next box, i.e., &#39;boxTypeChoiceLookahead&#39; set to 0, we would select Box A. It costs $2 per item, whereas Box B is $2.50 per item. Box A is opened, 6 items are placed inside, and now 2 remain. To pack the last 2, Box B would be selected, as 2 items for $10 is $5 per item, and Box A&#39;s $12 is $6 per item.&lt;/p&gt;&lt;p&gt;Alternatively, if &#39;boxTypeChoiceLookahead&#39; is set to 1, the boxType that provides the lowest cost per item &lt;i&gt;including&lt;/i&gt; the lookahead boxType(s) would be selected. In this case, we find we need 2 of Box B, for $20 total, to fit all 8 items, or $2.50 per item, and would need 1 of Box A and 1 of Box B if Box A is selected first, for $22 total or $2.75 per item. Box B would be used.&lt;/p&gt;&lt;p&gt;Please note that &#39;boxTypeChoiceLookahead&#39;, especially when combined with the &#39;actual&#39; &#39;boxTypeChoiceStyle&#39; can have significant performance impacts. 0 is recommended for real-time use cases.&lt;/p&gt;.</param>
        /// <param name="boxTypeChoiceGoal">The objective to evaluate boxTypeChoices by. &#39;lowest-cost&#39; minimizes price or volume cost of boxTypes selected, &#39;most-items&#39; maximizes item count per box opened, i.e., fewest total boxes used. (default to BoxTypeChoiceGoalEnum.LowestCost).</param>
        /// <param name="boxesPerItemSetMax">The maximum number of boxes that a single ItemSet&#39;s member items (i.e., all that share the same refId) can be spread across. Any items that do not fit within this number of boxes will be precluded from packing and returned in the leftovers array. The default setting of 0, a negative number, and null are all equivalent and indicate no maximum limit..</param>
        /// <param name="valueTiebreaker">The tiebreaker to use in the event to box type choices are otherwise completely equal. Default is \&quot;volume\&quot;, alternative is \&quot;weight\&quot;. (default to ValueTiebreakerEnum.Volume).</param>
        public Pack(string key = default(string), bool? layFlat = false, bool? interlock = false, bool? corners = true, List<ItemSet> itemSets = default(List<ItemSet>), List<BoxType> boxTypes = default(List<BoxType>), List<Box> boxes = default(List<Box>), decimal? usableSpace = default(decimal?), decimal? reservedSpace = default(decimal?), List<BoxTypeSet> boxTypeSets = default(List<BoxTypeSet>), Object eye = default(Object), Object packOrigin = default(Object), int? zone = default(int?), List<Rule> rules = default(List<Rule>), bool? random = false, int? n = default(int?), int? randomMaxDimension = default(int?), int? randomMaxWeight = default(int?), int? randomMaxQuantity = default(int?), bool? seed = true, int? seedValue = default(int?), int? imgSize = default(int?), TemplateEnum? template = default(TemplateEnum?), bool? includeScripts = true, bool? includeImages = true, ImageFormatEnum? imageFormat = ImageFormatEnum.Svg, List<int?> coordOrder = default(List<int?>), bool? cohortPacking = false, int? cohortMax = default(int?), decimal? allowableOverhang = default(decimal?), PlacementStyleEnum? placementStyle = PlacementStyleEnum.Default, ItemSortEnum? itemSort = ItemSortEnum.Combined, bool? itemSortReverse = false, bool? itemInitialOrientationBestForBox = false, bool? itemInitialOrientationPreferred = true, int? itemOrientationSearchDepth = default(int?), bool? sequenceSort = false, bool? sequenceHeatMap = false, int? maxSequenceDistance = default(int?), BoxTypeChoiceStyleEnum? boxTypeChoiceStyle = BoxTypeChoiceStyleEnum.Actual, int? boxTypeChoiceLookahead = default(int?), BoxTypeChoiceGoalEnum? boxTypeChoiceGoal = BoxTypeChoiceGoalEnum.LowestCost, int? boxesPerItemSetMax = default(int?), ValueTiebreakerEnum? valueTiebreaker = ValueTiebreakerEnum.Volume)
        {
            this.Key = key;
            // use default value if no "layFlat" provided
            if (layFlat == null)
            {
                this.LayFlat = false;
            }
            else
            {
                this.LayFlat = layFlat;
            }
            // use default value if no "interlock" provided
            if (interlock == null)
            {
                this.Interlock = false;
            }
            else
            {
                this.Interlock = interlock;
            }
            // use default value if no "corners" provided
            if (corners == null)
            {
                this.Corners = true;
            }
            else
            {
                this.Corners = corners;
            }
            this.ItemSets = itemSets;
            this.BoxTypes = boxTypes;
            this.Boxes = boxes;
            this.UsableSpace = usableSpace;
            this.ReservedSpace = reservedSpace;
            this.BoxTypeSets = boxTypeSets;
            this.Eye = eye;
            this.PackOrigin = packOrigin;
            this.Zone = zone;
            this.Rules = rules;
            // use default value if no "random" provided
            if (random == null)
            {
                this.Random = false;
            }
            else
            {
                this.Random = random;
            }
            this.N = n;
            this.RandomMaxDimension = randomMaxDimension;
            this.RandomMaxWeight = randomMaxWeight;
            this.RandomMaxQuantity = randomMaxQuantity;
            // use default value if no "seed" provided
            if (seed == null)
            {
                this.Seed = true;
            }
            else
            {
                this.Seed = seed;
            }
            this.SeedValue = seedValue;
            this.ImgSize = imgSize;
            this.Template = template;
            // use default value if no "includeScripts" provided
            if (includeScripts == null)
            {
                this.IncludeScripts = true;
            }
            else
            {
                this.IncludeScripts = includeScripts;
            }
            // use default value if no "includeImages" provided
            if (includeImages == null)
            {
                this.IncludeImages = true;
            }
            else
            {
                this.IncludeImages = includeImages;
            }
            // use default value if no "imageFormat" provided
            if (imageFormat == null)
            {
                this.ImageFormat = ImageFormatEnum.Svg;
            }
            else
            {
                this.ImageFormat = imageFormat;
            }
            this.CoordOrder = coordOrder;
            // use default value if no "cohortPacking" provided
            if (cohortPacking == null)
            {
                this.CohortPacking = false;
            }
            else
            {
                this.CohortPacking = cohortPacking;
            }
            this.CohortMax = cohortMax;
            this.AllowableOverhang = allowableOverhang;
            // use default value if no "placementStyle" provided
            if (placementStyle == null)
            {
                this.PlacementStyle = PlacementStyleEnum.Default;
            }
            else
            {
                this.PlacementStyle = placementStyle;
            }
            // use default value if no "itemSort" provided
            if (itemSort == null)
            {
                this.ItemSort = ItemSortEnum.Combined;
            }
            else
            {
                this.ItemSort = itemSort;
            }
            // use default value if no "itemSortReverse" provided
            if (itemSortReverse == null)
            {
                this.ItemSortReverse = false;
            }
            else
            {
                this.ItemSortReverse = itemSortReverse;
            }
            // use default value if no "itemInitialOrientationBestForBox" provided
            if (itemInitialOrientationBestForBox == null)
            {
                this.ItemInitialOrientationBestForBox = false;
            }
            else
            {
                this.ItemInitialOrientationBestForBox = itemInitialOrientationBestForBox;
            }
            // use default value if no "itemInitialOrientationPreferred" provided
            if (itemInitialOrientationPreferred == null)
            {
                this.ItemInitialOrientationPreferred = true;
            }
            else
            {
                this.ItemInitialOrientationPreferred = itemInitialOrientationPreferred;
            }
            this.ItemOrientationSearchDepth = itemOrientationSearchDepth;
            // use default value if no "sequenceSort" provided
            if (sequenceSort == null)
            {
                this.SequenceSort = false;
            }
            else
            {
                this.SequenceSort = sequenceSort;
            }
            // use default value if no "sequenceHeatMap" provided
            if (sequenceHeatMap == null)
            {
                this.SequenceHeatMap = false;
            }
            else
            {
                this.SequenceHeatMap = sequenceHeatMap;
            }
            this.MaxSequenceDistance = maxSequenceDistance;
            // use default value if no "boxTypeChoiceStyle" provided
            if (boxTypeChoiceStyle == null)
            {
                this.BoxTypeChoiceStyle = BoxTypeChoiceStyleEnum.Actual;
            }
            else
            {
                this.BoxTypeChoiceStyle = boxTypeChoiceStyle;
            }
            this.BoxTypeChoiceLookahead = boxTypeChoiceLookahead;
            // use default value if no "boxTypeChoiceGoal" provided
            if (boxTypeChoiceGoal == null)
            {
                this.BoxTypeChoiceGoal = BoxTypeChoiceGoalEnum.LowestCost;
            }
            else
            {
                this.BoxTypeChoiceGoal = boxTypeChoiceGoal;
            }
            this.BoxesPerItemSetMax = boxesPerItemSetMax;
            // use default value if no "valueTiebreaker" provided
            if (valueTiebreaker == null)
            {
                this.ValueTiebreaker = ValueTiebreakerEnum.Volume;
            }
            else
            {
                this.ValueTiebreaker = valueTiebreaker;
            }
        }
        
        /// <summary>
        /// issued API key.
        /// </summary>
        /// <value>issued API key.</value>
        [DataMember(Name="key", EmitDefaultValue=false)]
        public string Key { get; set; }

        /// <summary>
        /// aligns all items laying flat. If possible, it may create a \&quot;brick-laying\&quot; pattern to increase stability.
        /// </summary>
        /// <value>aligns all items laying flat. If possible, it may create a \&quot;brick-laying\&quot; pattern to increase stability.</value>
        [DataMember(Name="layFlat", EmitDefaultValue=false)]
        public bool? LayFlat { get; set; }

        /// <summary>
        /// alternates layFlat orientation by layer, so as to create an interlocked placement pattern and improve item stability.
        /// </summary>
        /// <value>alternates layFlat orientation by layer, so as to create an interlocked placement pattern and improve item stability.</value>
        [DataMember(Name="interlock", EmitDefaultValue=false)]
        public bool? Interlock { get; set; }

        /// <summary>
        /// only pack items at valid corner points of other items (optimal)
        /// </summary>
        /// <value>only pack items at valid corner points of other items (optimal)</value>
        [DataMember(Name="corners", EmitDefaultValue=false)]
        public bool? Corners { get; set; }

        /// <summary>
        /// item set definitions if not creating random items.
        /// </summary>
        /// <value>item set definitions if not creating random items.</value>
        [DataMember(Name="itemSets", EmitDefaultValue=false)]
        public List<ItemSet> ItemSets { get; set; }

        /// <summary>
        /// box type definitions for packing, will override boxTypeSets defined.
        /// </summary>
        /// <value>box type definitions for packing, will override boxTypeSets defined.</value>
        [DataMember(Name="boxTypes", EmitDefaultValue=false)]
        public List<BoxType> BoxTypes { get; set; }

        /// <summary>
        /// pre-packed boxes, including any items specified that will be packed and excess space used before any new boxes are created.
        /// </summary>
        /// <value>pre-packed boxes, including any items specified that will be packed and excess space used before any new boxes are created.</value>
        [DataMember(Name="boxes", EmitDefaultValue=false)]
        public List<Box> Boxes { get; set; }

        /// <summary>
        /// an estimate of typical box utilization for the quick \&quot;estimated\&quot; boxTypeChoiceStyle, which will be used to ensure \&quot;estimated\&quot; box type choices are not overly optimistic regarding potential volume utilization.
        /// </summary>
        /// <value>an estimate of typical box utilization for the quick \&quot;estimated\&quot; boxTypeChoiceStyle, which will be used to ensure \&quot;estimated\&quot; box type choices are not overly optimistic regarding potential volume utilization.</value>
        [DataMember(Name="usableSpace", EmitDefaultValue=false)]
        public decimal? UsableSpace { get; set; }

        /// <summary>
        /// space in boxes that is reserved, i.e., for packing material.
        /// </summary>
        /// <value>space in boxes that is reserved, i.e., for packing material.</value>
        [DataMember(Name="reservedSpace", EmitDefaultValue=false)]
        public decimal? ReservedSpace { get; set; }

        /// <summary>
        /// predefined box types to be used, separated by commas. Will be overridden by boxTypes. Acceptable values are &lt;ul&gt;&lt;li&gt;\&quot;fedex\&quot;- -FedEx OneRate&lt;/li&gt;&lt;li&gt;\&quot;usps\&quot;- -USPS Priority Flat Rate&lt;/li&gt;&lt;li&gt;\&quot;pallet\&quot;- -full-, half-, and quarter-sized 48\&quot;x40\&quot; pallets.
        /// </summary>
        /// <value>predefined box types to be used, separated by commas. Will be overridden by boxTypes. Acceptable values are &lt;ul&gt;&lt;li&gt;\&quot;fedex\&quot;- -FedEx OneRate&lt;/li&gt;&lt;li&gt;\&quot;usps\&quot;- -USPS Priority Flat Rate&lt;/li&gt;&lt;li&gt;\&quot;pallet\&quot;- -full-, half-, and quarter-sized 48\&quot;x40\&quot; pallets.</value>
        [DataMember(Name="boxTypeSets", EmitDefaultValue=false)]
        public List<BoxTypeSet> BoxTypeSets { get; set; }

        /// <summary>
        /// The x,y,z coordinates of the virtual eye looking at the package for visualization purposes. Default is isometric, \&quot;1,1,1\&quot;. To generate a side view, one could use \&quot;0.001,1.0,0.001\&quot;.
        /// </summary>
        /// <value>The x,y,z coordinates of the virtual eye looking at the package for visualization purposes. Default is isometric, \&quot;1,1,1\&quot;. To generate a side view, one could use \&quot;0.001,1.0,0.001\&quot;.</value>
        [DataMember(Name="eye", EmitDefaultValue=false)]
        public Object Eye { get; set; }

        /// <summary>
        /// the x,y,z coordinates of an optional packing origin. A packing origin is used to create more balanced packing for situations where load needs to be considered. E.g., for a 40\&quot;x48\&quot; pallet, a packOrigin representing the middle of the pallet, \&quot;0,20,24\&quot;, would cause placement to minimize the distance of the packed items from the center of the pallet.
        /// </summary>
        /// <value>the x,y,z coordinates of an optional packing origin. A packing origin is used to create more balanced packing for situations where load needs to be considered. E.g., for a 40\&quot;x48\&quot; pallet, a packOrigin representing the middle of the pallet, \&quot;0,20,24\&quot;, would cause placement to minimize the distance of the packed items from the center of the pallet.</value>
        [DataMember(Name="packOrigin", EmitDefaultValue=false)]
        public Object PackOrigin { get; set; }

        /// <summary>
        /// &lt;b&gt;[experimental]&lt;/b&gt; the shipping zone in order to use basic zone-based price optimization.
        /// </summary>
        /// <value>&lt;b&gt;[experimental]&lt;/b&gt; the shipping zone in order to use basic zone-based price optimization.</value>
        [DataMember(Name="zone", EmitDefaultValue=false)]
        public int? Zone { get; set; }

        /// <summary>
        /// Array of packing rules.
        /// </summary>
        /// <value>Array of packing rules.</value>
        [DataMember(Name="rules", EmitDefaultValue=false)]
        public List<Rule> Rules { get; set; }

        /// <summary>
        /// create random items
        /// </summary>
        /// <value>create random items</value>
        [DataMember(Name="random", EmitDefaultValue=false)]
        public bool? Random { get; set; }

        /// <summary>
        /// number of random items to generate and the quantity of each if \&quot;random\&quot; is set to true. a value of 5 would create 5 different items with a quantity of 5 each, making the total item quantity equal to n&amp;sup2;
        /// </summary>
        /// <value>number of random items to generate and the quantity of each if \&quot;random\&quot; is set to true. a value of 5 would create 5 different items with a quantity of 5 each, making the total item quantity equal to n&amp;sup2;</value>
        [DataMember(Name="n", EmitDefaultValue=false)]
        public int? N { get; set; }

        /// <summary>
        /// maximum item dimension along a single axis for randomly generated items.
        /// </summary>
        /// <value>maximum item dimension along a single axis for randomly generated items.</value>
        [DataMember(Name="randomMaxDimension", EmitDefaultValue=false)]
        public int? RandomMaxDimension { get; set; }

        /// <summary>
        /// maximum item weight for randomly generated items.
        /// </summary>
        /// <value>maximum item weight for randomly generated items.</value>
        [DataMember(Name="randomMaxWeight", EmitDefaultValue=false)]
        public int? RandomMaxWeight { get; set; }

        /// <summary>
        /// maximum quantity for randomly generated items.
        /// </summary>
        /// <value>maximum quantity for randomly generated items.</value>
        [DataMember(Name="randomMaxQuantity", EmitDefaultValue=false)]
        public int? RandomMaxQuantity { get; set; }

        /// <summary>
        /// if random is selected, seed the random number generator to deterministically generate random items to pack.
        /// </summary>
        /// <value>if random is selected, seed the random number generator to deterministically generate random items to pack.</value>
        [DataMember(Name="seed", EmitDefaultValue=false)]
        public bool? Seed { get; set; }

        /// <summary>
        /// if seed is set to true, specifies a non-default seed for the random number generator.
        /// </summary>
        /// <value>if seed is set to true, specifies a non-default seed for the random number generator.</value>
        [DataMember(Name="seedValue", EmitDefaultValue=false)]
        public int? SeedValue { get; set; }

        /// <summary>
        /// width of rendered SVGs in pixels.
        /// </summary>
        /// <value>width of rendered SVGs in pixels.</value>
        [DataMember(Name="imgSize", EmitDefaultValue=false)]
        public int? ImgSize { get; set; }


        /// <summary>
        /// include inline javascripts and styles for base template
        /// </summary>
        /// <value>include inline javascripts and styles for base template</value>
        [DataMember(Name="includeScripts", EmitDefaultValue=false)]
        public bool? IncludeScripts { get; set; }

        /// <summary>
        /// include inline images, default is always on
        /// </summary>
        /// <value>include inline images, default is always on</value>
        [DataMember(Name="includeImages", EmitDefaultValue=false)]
        public bool? IncludeImages { get; set; }


        /// <summary>
        /// If placementStyle is set to \&quot;default\&quot;, coordOrder sets the placement priority of axes ascendingly. \&quot;0,1,2\&quot; would search for placement points along the Z(length,\&quot;2\&quot;), then Y(width,\&quot;1\&quot;), and finally X(height\&quot;0\&quot;). Keep in mind that in the default rendering the \&quot;up\&quot; direction is X and the other axes follow the right-hand rule. This is useful for different packing methods. E.g., Utilizing \&quot;2,0,1\&quot; would pack a shipping container first in the Y(width) direction, then in the X(height) direction, and finally in the Z(length) direction, replication a floor-to-ceiling, front-to-back loading method.
        /// </summary>
        /// <value>If placementStyle is set to \&quot;default\&quot;, coordOrder sets the placement priority of axes ascendingly. \&quot;0,1,2\&quot; would search for placement points along the Z(length,\&quot;2\&quot;), then Y(width,\&quot;1\&quot;), and finally X(height\&quot;0\&quot;). Keep in mind that in the default rendering the \&quot;up\&quot; direction is X and the other axes follow the right-hand rule. This is useful for different packing methods. E.g., Utilizing \&quot;2,0,1\&quot; would pack a shipping container first in the Y(width) direction, then in the X(height) direction, and finally in the Z(length) direction, replication a floor-to-ceiling, front-to-back loading method.</value>
        [DataMember(Name="coordOrder", EmitDefaultValue=false)]
        public List<int?> CoordOrder { get; set; }

        /// <summary>
        /// if selected, will ensure that all like items will be packed together, in no more than [cohortMax] different groups within a single container.
        /// </summary>
        /// <value>if selected, will ensure that all like items will be packed together, in no more than [cohortMax] different groups within a single container.</value>
        [DataMember(Name="cohortPacking", EmitDefaultValue=false)]
        public bool? CohortPacking { get; set; }

        /// <summary>
        /// the maximum number of contiguous cohorts for a given item type within a single container. E.g., if you pack 40 chairs in a single container, a cohortMax of 2 could yield one (all 40 chairs in a single block if space is availabe) or two (say, 25 chairs in one corner and 15 in the other) contiguous cohorts.
        /// </summary>
        /// <value>the maximum number of contiguous cohorts for a given item type within a single container. E.g., if you pack 40 chairs in a single container, a cohortMax of 2 could yield one (all 40 chairs in a single block if space is availabe) or two (say, 25 chairs in one corner and 15 in the other) contiguous cohorts.</value>
        [DataMember(Name="cohortMax", EmitDefaultValue=false)]
        public int? CohortMax { get; set; }

        /// <summary>
        /// The amount an item can overhang lower items that it is placed upon. The units are whatever units the box and item dimensions are given in. By convention, inches.
        /// </summary>
        /// <value>The amount an item can overhang lower items that it is placed upon. The units are whatever units the box and item dimensions are given in. By convention, inches.</value>
        [DataMember(Name="allowableOverhang", EmitDefaultValue=false)]
        public decimal? AllowableOverhang { get; set; }



        /// <summary>
        /// Whether or not to reverse the itemSort utilized.
        /// </summary>
        /// <value>Whether or not to reverse the itemSort utilized.</value>
        [DataMember(Name="itemSortReverse", EmitDefaultValue=false)]
        public bool? ItemSortReverse { get; set; }

        /// <summary>
        /// For all items where orientation flipping is used, the orientation producing the highest multiple of items fit per remaining dimension is used as the first orientation. This option should be enabled when packing high quantities of single item types, but may produce inconsistent results in other cases. Defers to item orientation locking and itemOrientationSearchDepth &gt; 0 if a superior result is found.
        /// </summary>
        /// <value>For all items where orientation flipping is used, the orientation producing the highest multiple of items fit per remaining dimension is used as the first orientation. This option should be enabled when packing high quantities of single item types, but may produce inconsistent results in other cases. Defers to item orientation locking and itemOrientationSearchDepth &gt; 0 if a superior result is found.</value>
        [DataMember(Name="itemInitialOrientationBestForBox", EmitDefaultValue=false)]
        public bool? ItemInitialOrientationBestForBox { get; set; }

        /// <summary>
        /// Whether to attempt packing by either greedily placing items or placing all allowable combinations of initial item orientations and selecting the most performant. When true, items will be placed immediately using the orientation reflected by their dimensions definition and will only be flipped if a placement cannot be found and the item rules allow orientation changes. When false, all allowable initial orientation combinations will be attempted for each item in each box.
        /// </summary>
        /// <value>Whether to attempt packing by either greedily placing items or placing all allowable combinations of initial item orientations and selecting the most performant. When true, items will be placed immediately using the orientation reflected by their dimensions definition and will only be flipped if a placement cannot be found and the item rules allow orientation changes. When false, all allowable initial orientation combinations will be attempted for each item in each box.</value>
        [DataMember(Name="itemInitialOrientationPreferred", EmitDefaultValue=false)]
        public bool? ItemInitialOrientationPreferred { get; set; }

        /// <summary>
        /// When itemInitialOrientationPreferred is set to false, the itemOrientationSearchDepth is the number of unique, sorted, groups of Items sharing the same ItemSet definition that will be have every combination of initial orientation attempted. A value of 1 signifies that only the first item (and others still unpacked from its ItemSet) will have every orientation attempted and the engine subsequently selecting the most performant. A value of 2 signifies that the first groups of unpacked items, each sharing an ItemSet, will have every combination of orientation attempted. Increasing this value from 1 can very rapidly result in excessive complexity and a timeout error instead of a result, so discretion is advised.
        /// </summary>
        /// <value>When itemInitialOrientationPreferred is set to false, the itemOrientationSearchDepth is the number of unique, sorted, groups of Items sharing the same ItemSet definition that will be have every combination of initial orientation attempted. A value of 1 signifies that only the first item (and others still unpacked from its ItemSet) will have every orientation attempted and the engine subsequently selecting the most performant. A value of 2 signifies that the first groups of unpacked items, each sharing an ItemSet, will have every combination of orientation attempted. Increasing this value from 1 can very rapidly result in excessive complexity and a timeout error instead of a result, so discretion is advised.</value>
        [DataMember(Name="itemOrientationSearchDepth", EmitDefaultValue=false)]
        public int? ItemOrientationSearchDepth { get; set; }

        /// <summary>
        /// Whether or not the items should be initially sorted by their sequence value instead of by the specified itemSort. This is not always useful, as the default \&quot;biggest-first\&quot; volume sort is very effective for items, and constraining by maxSequenceDistance is applied regardless of this field. That said, for doing custom pre-sorts such as weight-based instead of volume based, this value should be set to true.
        /// </summary>
        /// <value>Whether or not the items should be initially sorted by their sequence value instead of by the specified itemSort. This is not always useful, as the default \&quot;biggest-first\&quot; volume sort is very effective for items, and constraining by maxSequenceDistance is applied regardless of this field. That said, for doing custom pre-sorts such as weight-based instead of volume based, this value should be set to true.</value>
        [DataMember(Name="sequenceSort", EmitDefaultValue=false)]
        public bool? SequenceSort { get; set; }

        /// <summary>
        /// Colorize items solely by their sequence value, light when sequence is high, dark when it is low. Useful for indicating item bin location, weight, or other sequence property that may not be apparent from the default visualization.
        /// </summary>
        /// <value>Colorize items solely by their sequence value, light when sequence is high, dark when it is low. Useful for indicating item bin location, weight, or other sequence property that may not be apparent from the default visualization.</value>
        [DataMember(Name="sequenceHeatMap", EmitDefaultValue=false)]
        public bool? SequenceHeatMap { get; set; }

        /// <summary>
        /// This is the maximum distance allowable between two sequence values of items packed in a common box. E.g., \&quot;Distance\&quot; for an item sequence composed of aisle/bin combinations of \&quot;0401\&quot; and \&quot;1228\&quot; has a sequence distance of \\|1228 - 401\\| &#x3D; 827
        /// </summary>
        /// <value>This is the maximum distance allowable between two sequence values of items packed in a common box. E.g., \&quot;Distance\&quot; for an item sequence composed of aisle/bin combinations of \&quot;0401\&quot; and \&quot;1228\&quot; has a sequence distance of \\|1228 - 401\\| &#x3D; 827</value>
        [DataMember(Name="maxSequenceDistance", EmitDefaultValue=false)]
        public int? MaxSequenceDistance { get; set; }


        /// <summary>
        /// &lt;p&gt;When selecting the next available boxType, we must consider how far to look ahead.&lt;/p&gt;&lt;p&gt;Consider we have 8 items of identical dimensions, and two flat rate boxTypes. It is found that Box A can fit 6 items, and costs $12. Box B can fit 4 items, and costs $10.&lt;/p&gt;&lt;p&gt;If we consider only the next box, i.e., &#39;boxTypeChoiceLookahead&#39; set to 0, we would select Box A. It costs $2 per item, whereas Box B is $2.50 per item. Box A is opened, 6 items are placed inside, and now 2 remain. To pack the last 2, Box B would be selected, as 2 items for $10 is $5 per item, and Box A&#39;s $12 is $6 per item.&lt;/p&gt;&lt;p&gt;Alternatively, if &#39;boxTypeChoiceLookahead&#39; is set to 1, the boxType that provides the lowest cost per item &lt;i&gt;including&lt;/i&gt; the lookahead boxType(s) would be selected. In this case, we find we need 2 of Box B, for $20 total, to fit all 8 items, or $2.50 per item, and would need 1 of Box A and 1 of Box B if Box A is selected first, for $22 total or $2.75 per item. Box B would be used.&lt;/p&gt;&lt;p&gt;Please note that &#39;boxTypeChoiceLookahead&#39;, especially when combined with the &#39;actual&#39; &#39;boxTypeChoiceStyle&#39; can have significant performance impacts. 0 is recommended for real-time use cases.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;When selecting the next available boxType, we must consider how far to look ahead.&lt;/p&gt;&lt;p&gt;Consider we have 8 items of identical dimensions, and two flat rate boxTypes. It is found that Box A can fit 6 items, and costs $12. Box B can fit 4 items, and costs $10.&lt;/p&gt;&lt;p&gt;If we consider only the next box, i.e., &#39;boxTypeChoiceLookahead&#39; set to 0, we would select Box A. It costs $2 per item, whereas Box B is $2.50 per item. Box A is opened, 6 items are placed inside, and now 2 remain. To pack the last 2, Box B would be selected, as 2 items for $10 is $5 per item, and Box A&#39;s $12 is $6 per item.&lt;/p&gt;&lt;p&gt;Alternatively, if &#39;boxTypeChoiceLookahead&#39; is set to 1, the boxType that provides the lowest cost per item &lt;i&gt;including&lt;/i&gt; the lookahead boxType(s) would be selected. In this case, we find we need 2 of Box B, for $20 total, to fit all 8 items, or $2.50 per item, and would need 1 of Box A and 1 of Box B if Box A is selected first, for $22 total or $2.75 per item. Box B would be used.&lt;/p&gt;&lt;p&gt;Please note that &#39;boxTypeChoiceLookahead&#39;, especially when combined with the &#39;actual&#39; &#39;boxTypeChoiceStyle&#39; can have significant performance impacts. 0 is recommended for real-time use cases.&lt;/p&gt;</value>
        [DataMember(Name="boxTypeChoiceLookahead", EmitDefaultValue=false)]
        public int? BoxTypeChoiceLookahead { get; set; }


        /// <summary>
        /// The maximum number of boxes that a single ItemSet&#39;s member items (i.e., all that share the same refId) can be spread across. Any items that do not fit within this number of boxes will be precluded from packing and returned in the leftovers array. The default setting of 0, a negative number, and null are all equivalent and indicate no maximum limit.
        /// </summary>
        /// <value>The maximum number of boxes that a single ItemSet&#39;s member items (i.e., all that share the same refId) can be spread across. Any items that do not fit within this number of boxes will be precluded from packing and returned in the leftovers array. The default setting of 0, a negative number, and null are all equivalent and indicate no maximum limit.</value>
        [DataMember(Name="boxesPerItemSetMax", EmitDefaultValue=false)]
        public int? BoxesPerItemSetMax { get; set; }


        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Pack {\n");
            sb.Append("  Key: ").Append(Key).Append("\n");
            sb.Append("  LayFlat: ").Append(LayFlat).Append("\n");
            sb.Append("  Interlock: ").Append(Interlock).Append("\n");
            sb.Append("  Corners: ").Append(Corners).Append("\n");
            sb.Append("  ItemSets: ").Append(ItemSets).Append("\n");
            sb.Append("  BoxTypes: ").Append(BoxTypes).Append("\n");
            sb.Append("  Boxes: ").Append(Boxes).Append("\n");
            sb.Append("  UsableSpace: ").Append(UsableSpace).Append("\n");
            sb.Append("  ReservedSpace: ").Append(ReservedSpace).Append("\n");
            sb.Append("  BoxTypeSets: ").Append(BoxTypeSets).Append("\n");
            sb.Append("  Eye: ").Append(Eye).Append("\n");
            sb.Append("  PackOrigin: ").Append(PackOrigin).Append("\n");
            sb.Append("  Zone: ").Append(Zone).Append("\n");
            sb.Append("  Rules: ").Append(Rules).Append("\n");
            sb.Append("  Random: ").Append(Random).Append("\n");
            sb.Append("  N: ").Append(N).Append("\n");
            sb.Append("  RandomMaxDimension: ").Append(RandomMaxDimension).Append("\n");
            sb.Append("  RandomMaxWeight: ").Append(RandomMaxWeight).Append("\n");
            sb.Append("  RandomMaxQuantity: ").Append(RandomMaxQuantity).Append("\n");
            sb.Append("  Seed: ").Append(Seed).Append("\n");
            sb.Append("  SeedValue: ").Append(SeedValue).Append("\n");
            sb.Append("  ImgSize: ").Append(ImgSize).Append("\n");
            sb.Append("  Template: ").Append(Template).Append("\n");
            sb.Append("  IncludeScripts: ").Append(IncludeScripts).Append("\n");
            sb.Append("  IncludeImages: ").Append(IncludeImages).Append("\n");
            sb.Append("  ImageFormat: ").Append(ImageFormat).Append("\n");
            sb.Append("  CoordOrder: ").Append(CoordOrder).Append("\n");
            sb.Append("  CohortPacking: ").Append(CohortPacking).Append("\n");
            sb.Append("  CohortMax: ").Append(CohortMax).Append("\n");
            sb.Append("  AllowableOverhang: ").Append(AllowableOverhang).Append("\n");
            sb.Append("  PlacementStyle: ").Append(PlacementStyle).Append("\n");
            sb.Append("  ItemSort: ").Append(ItemSort).Append("\n");
            sb.Append("  ItemSortReverse: ").Append(ItemSortReverse).Append("\n");
            sb.Append("  ItemInitialOrientationBestForBox: ").Append(ItemInitialOrientationBestForBox).Append("\n");
            sb.Append("  ItemInitialOrientationPreferred: ").Append(ItemInitialOrientationPreferred).Append("\n");
            sb.Append("  ItemOrientationSearchDepth: ").Append(ItemOrientationSearchDepth).Append("\n");
            sb.Append("  SequenceSort: ").Append(SequenceSort).Append("\n");
            sb.Append("  SequenceHeatMap: ").Append(SequenceHeatMap).Append("\n");
            sb.Append("  MaxSequenceDistance: ").Append(MaxSequenceDistance).Append("\n");
            sb.Append("  BoxTypeChoiceStyle: ").Append(BoxTypeChoiceStyle).Append("\n");
            sb.Append("  BoxTypeChoiceLookahead: ").Append(BoxTypeChoiceLookahead).Append("\n");
            sb.Append("  BoxTypeChoiceGoal: ").Append(BoxTypeChoiceGoal).Append("\n");
            sb.Append("  BoxesPerItemSetMax: ").Append(BoxesPerItemSetMax).Append("\n");
            sb.Append("  ValueTiebreaker: ").Append(ValueTiebreaker).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Pack);
        }

        /// <summary>
        /// Returns true if Pack instances are equal
        /// </summary>
        /// <param name="input">Instance of Pack to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Pack input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Key == input.Key ||
                    (this.Key != null &&
                    this.Key.Equals(input.Key))
                ) && 
                (
                    this.LayFlat == input.LayFlat ||
                    (this.LayFlat != null &&
                    this.LayFlat.Equals(input.LayFlat))
                ) && 
                (
                    this.Interlock == input.Interlock ||
                    (this.Interlock != null &&
                    this.Interlock.Equals(input.Interlock))
                ) && 
                (
                    this.Corners == input.Corners ||
                    (this.Corners != null &&
                    this.Corners.Equals(input.Corners))
                ) && 
                (
                    this.ItemSets == input.ItemSets ||
                    this.ItemSets != null &&
                    this.ItemSets.SequenceEqual(input.ItemSets)
                ) && 
                (
                    this.BoxTypes == input.BoxTypes ||
                    this.BoxTypes != null &&
                    this.BoxTypes.SequenceEqual(input.BoxTypes)
                ) && 
                (
                    this.Boxes == input.Boxes ||
                    this.Boxes != null &&
                    this.Boxes.SequenceEqual(input.Boxes)
                ) && 
                (
                    this.UsableSpace == input.UsableSpace ||
                    (this.UsableSpace != null &&
                    this.UsableSpace.Equals(input.UsableSpace))
                ) && 
                (
                    this.ReservedSpace == input.ReservedSpace ||
                    (this.ReservedSpace != null &&
                    this.ReservedSpace.Equals(input.ReservedSpace))
                ) && 
                (
                    this.BoxTypeSets == input.BoxTypeSets ||
                    this.BoxTypeSets != null &&
                    this.BoxTypeSets.SequenceEqual(input.BoxTypeSets)
                ) && 
                (
                    this.Eye == input.Eye ||
                    (this.Eye != null &&
                    this.Eye.Equals(input.Eye))
                ) && 
                (
                    this.PackOrigin == input.PackOrigin ||
                    (this.PackOrigin != null &&
                    this.PackOrigin.Equals(input.PackOrigin))
                ) && 
                (
                    this.Zone == input.Zone ||
                    (this.Zone != null &&
                    this.Zone.Equals(input.Zone))
                ) && 
                (
                    this.Rules == input.Rules ||
                    this.Rules != null &&
                    this.Rules.SequenceEqual(input.Rules)
                ) && 
                (
                    this.Random == input.Random ||
                    (this.Random != null &&
                    this.Random.Equals(input.Random))
                ) && 
                (
                    this.N == input.N ||
                    (this.N != null &&
                    this.N.Equals(input.N))
                ) && 
                (
                    this.RandomMaxDimension == input.RandomMaxDimension ||
                    (this.RandomMaxDimension != null &&
                    this.RandomMaxDimension.Equals(input.RandomMaxDimension))
                ) && 
                (
                    this.RandomMaxWeight == input.RandomMaxWeight ||
                    (this.RandomMaxWeight != null &&
                    this.RandomMaxWeight.Equals(input.RandomMaxWeight))
                ) && 
                (
                    this.RandomMaxQuantity == input.RandomMaxQuantity ||
                    (this.RandomMaxQuantity != null &&
                    this.RandomMaxQuantity.Equals(input.RandomMaxQuantity))
                ) && 
                (
                    this.Seed == input.Seed ||
                    (this.Seed != null &&
                    this.Seed.Equals(input.Seed))
                ) && 
                (
                    this.SeedValue == input.SeedValue ||
                    (this.SeedValue != null &&
                    this.SeedValue.Equals(input.SeedValue))
                ) && 
                (
                    this.ImgSize == input.ImgSize ||
                    (this.ImgSize != null &&
                    this.ImgSize.Equals(input.ImgSize))
                ) && 
                (
                    this.Template == input.Template ||
                    (this.Template != null &&
                    this.Template.Equals(input.Template))
                ) && 
                (
                    this.IncludeScripts == input.IncludeScripts ||
                    (this.IncludeScripts != null &&
                    this.IncludeScripts.Equals(input.IncludeScripts))
                ) && 
                (
                    this.IncludeImages == input.IncludeImages ||
                    (this.IncludeImages != null &&
                    this.IncludeImages.Equals(input.IncludeImages))
                ) && 
                (
                    this.ImageFormat == input.ImageFormat ||
                    (this.ImageFormat != null &&
                    this.ImageFormat.Equals(input.ImageFormat))
                ) && 
                (
                    this.CoordOrder == input.CoordOrder ||
                    this.CoordOrder != null &&
                    this.CoordOrder.SequenceEqual(input.CoordOrder)
                ) && 
                (
                    this.CohortPacking == input.CohortPacking ||
                    (this.CohortPacking != null &&
                    this.CohortPacking.Equals(input.CohortPacking))
                ) && 
                (
                    this.CohortMax == input.CohortMax ||
                    (this.CohortMax != null &&
                    this.CohortMax.Equals(input.CohortMax))
                ) && 
                (
                    this.AllowableOverhang == input.AllowableOverhang ||
                    (this.AllowableOverhang != null &&
                    this.AllowableOverhang.Equals(input.AllowableOverhang))
                ) && 
                (
                    this.PlacementStyle == input.PlacementStyle ||
                    (this.PlacementStyle != null &&
                    this.PlacementStyle.Equals(input.PlacementStyle))
                ) && 
                (
                    this.ItemSort == input.ItemSort ||
                    (this.ItemSort != null &&
                    this.ItemSort.Equals(input.ItemSort))
                ) && 
                (
                    this.ItemSortReverse == input.ItemSortReverse ||
                    (this.ItemSortReverse != null &&
                    this.ItemSortReverse.Equals(input.ItemSortReverse))
                ) && 
                (
                    this.ItemInitialOrientationBestForBox == input.ItemInitialOrientationBestForBox ||
                    (this.ItemInitialOrientationBestForBox != null &&
                    this.ItemInitialOrientationBestForBox.Equals(input.ItemInitialOrientationBestForBox))
                ) && 
                (
                    this.ItemInitialOrientationPreferred == input.ItemInitialOrientationPreferred ||
                    (this.ItemInitialOrientationPreferred != null &&
                    this.ItemInitialOrientationPreferred.Equals(input.ItemInitialOrientationPreferred))
                ) && 
                (
                    this.ItemOrientationSearchDepth == input.ItemOrientationSearchDepth ||
                    (this.ItemOrientationSearchDepth != null &&
                    this.ItemOrientationSearchDepth.Equals(input.ItemOrientationSearchDepth))
                ) && 
                (
                    this.SequenceSort == input.SequenceSort ||
                    (this.SequenceSort != null &&
                    this.SequenceSort.Equals(input.SequenceSort))
                ) && 
                (
                    this.SequenceHeatMap == input.SequenceHeatMap ||
                    (this.SequenceHeatMap != null &&
                    this.SequenceHeatMap.Equals(input.SequenceHeatMap))
                ) && 
                (
                    this.MaxSequenceDistance == input.MaxSequenceDistance ||
                    (this.MaxSequenceDistance != null &&
                    this.MaxSequenceDistance.Equals(input.MaxSequenceDistance))
                ) && 
                (
                    this.BoxTypeChoiceStyle == input.BoxTypeChoiceStyle ||
                    (this.BoxTypeChoiceStyle != null &&
                    this.BoxTypeChoiceStyle.Equals(input.BoxTypeChoiceStyle))
                ) && 
                (
                    this.BoxTypeChoiceLookahead == input.BoxTypeChoiceLookahead ||
                    (this.BoxTypeChoiceLookahead != null &&
                    this.BoxTypeChoiceLookahead.Equals(input.BoxTypeChoiceLookahead))
                ) && 
                (
                    this.BoxTypeChoiceGoal == input.BoxTypeChoiceGoal ||
                    (this.BoxTypeChoiceGoal != null &&
                    this.BoxTypeChoiceGoal.Equals(input.BoxTypeChoiceGoal))
                ) && 
                (
                    this.BoxesPerItemSetMax == input.BoxesPerItemSetMax ||
                    (this.BoxesPerItemSetMax != null &&
                    this.BoxesPerItemSetMax.Equals(input.BoxesPerItemSetMax))
                ) && 
                (
                    this.ValueTiebreaker == input.ValueTiebreaker ||
                    (this.ValueTiebreaker != null &&
                    this.ValueTiebreaker.Equals(input.ValueTiebreaker))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Key != null)
                    hashCode = hashCode * 59 + this.Key.GetHashCode();
                if (this.LayFlat != null)
                    hashCode = hashCode * 59 + this.LayFlat.GetHashCode();
                if (this.Interlock != null)
                    hashCode = hashCode * 59 + this.Interlock.GetHashCode();
                if (this.Corners != null)
                    hashCode = hashCode * 59 + this.Corners.GetHashCode();
                if (this.ItemSets != null)
                    hashCode = hashCode * 59 + this.ItemSets.GetHashCode();
                if (this.BoxTypes != null)
                    hashCode = hashCode * 59 + this.BoxTypes.GetHashCode();
                if (this.Boxes != null)
                    hashCode = hashCode * 59 + this.Boxes.GetHashCode();
                if (this.UsableSpace != null)
                    hashCode = hashCode * 59 + this.UsableSpace.GetHashCode();
                if (this.ReservedSpace != null)
                    hashCode = hashCode * 59 + this.ReservedSpace.GetHashCode();
                if (this.BoxTypeSets != null)
                    hashCode = hashCode * 59 + this.BoxTypeSets.GetHashCode();
                if (this.Eye != null)
                    hashCode = hashCode * 59 + this.Eye.GetHashCode();
                if (this.PackOrigin != null)
                    hashCode = hashCode * 59 + this.PackOrigin.GetHashCode();
                if (this.Zone != null)
                    hashCode = hashCode * 59 + this.Zone.GetHashCode();
                if (this.Rules != null)
                    hashCode = hashCode * 59 + this.Rules.GetHashCode();
                if (this.Random != null)
                    hashCode = hashCode * 59 + this.Random.GetHashCode();
                if (this.N != null)
                    hashCode = hashCode * 59 + this.N.GetHashCode();
                if (this.RandomMaxDimension != null)
                    hashCode = hashCode * 59 + this.RandomMaxDimension.GetHashCode();
                if (this.RandomMaxWeight != null)
                    hashCode = hashCode * 59 + this.RandomMaxWeight.GetHashCode();
                if (this.RandomMaxQuantity != null)
                    hashCode = hashCode * 59 + this.RandomMaxQuantity.GetHashCode();
                if (this.Seed != null)
                    hashCode = hashCode * 59 + this.Seed.GetHashCode();
                if (this.SeedValue != null)
                    hashCode = hashCode * 59 + this.SeedValue.GetHashCode();
                if (this.ImgSize != null)
                    hashCode = hashCode * 59 + this.ImgSize.GetHashCode();
                if (this.Template != null)
                    hashCode = hashCode * 59 + this.Template.GetHashCode();
                if (this.IncludeScripts != null)
                    hashCode = hashCode * 59 + this.IncludeScripts.GetHashCode();
                if (this.IncludeImages != null)
                    hashCode = hashCode * 59 + this.IncludeImages.GetHashCode();
                if (this.ImageFormat != null)
                    hashCode = hashCode * 59 + this.ImageFormat.GetHashCode();
                if (this.CoordOrder != null)
                    hashCode = hashCode * 59 + this.CoordOrder.GetHashCode();
                if (this.CohortPacking != null)
                    hashCode = hashCode * 59 + this.CohortPacking.GetHashCode();
                if (this.CohortMax != null)
                    hashCode = hashCode * 59 + this.CohortMax.GetHashCode();
                if (this.AllowableOverhang != null)
                    hashCode = hashCode * 59 + this.AllowableOverhang.GetHashCode();
                if (this.PlacementStyle != null)
                    hashCode = hashCode * 59 + this.PlacementStyle.GetHashCode();
                if (this.ItemSort != null)
                    hashCode = hashCode * 59 + this.ItemSort.GetHashCode();
                if (this.ItemSortReverse != null)
                    hashCode = hashCode * 59 + this.ItemSortReverse.GetHashCode();
                if (this.ItemInitialOrientationBestForBox != null)
                    hashCode = hashCode * 59 + this.ItemInitialOrientationBestForBox.GetHashCode();
                if (this.ItemInitialOrientationPreferred != null)
                    hashCode = hashCode * 59 + this.ItemInitialOrientationPreferred.GetHashCode();
                if (this.ItemOrientationSearchDepth != null)
                    hashCode = hashCode * 59 + this.ItemOrientationSearchDepth.GetHashCode();
                if (this.SequenceSort != null)
                    hashCode = hashCode * 59 + this.SequenceSort.GetHashCode();
                if (this.SequenceHeatMap != null)
                    hashCode = hashCode * 59 + this.SequenceHeatMap.GetHashCode();
                if (this.MaxSequenceDistance != null)
                    hashCode = hashCode * 59 + this.MaxSequenceDistance.GetHashCode();
                if (this.BoxTypeChoiceStyle != null)
                    hashCode = hashCode * 59 + this.BoxTypeChoiceStyle.GetHashCode();
                if (this.BoxTypeChoiceLookahead != null)
                    hashCode = hashCode * 59 + this.BoxTypeChoiceLookahead.GetHashCode();
                if (this.BoxTypeChoiceGoal != null)
                    hashCode = hashCode * 59 + this.BoxTypeChoiceGoal.GetHashCode();
                if (this.BoxesPerItemSetMax != null)
                    hashCode = hashCode * 59 + this.BoxesPerItemSetMax.GetHashCode();
                if (this.ValueTiebreaker != null)
                    hashCode = hashCode * 59 + this.ValueTiebreaker.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // UsableSpace (decimal?) maximum
            if(this.UsableSpace > (decimal?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for UsableSpace, must be a value less than or equal to 1.", new [] { "UsableSpace" });
            }

            // UsableSpace (decimal?) minimum
            if(this.UsableSpace < (decimal?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for UsableSpace, must be a value greater than or equal to 0.", new [] { "UsableSpace" });
            }

            // ReservedSpace (decimal?) maximum
            if(this.ReservedSpace > (decimal?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ReservedSpace, must be a value less than or equal to 1.", new [] { "ReservedSpace" });
            }

            // ReservedSpace (decimal?) minimum
            if(this.ReservedSpace < (decimal?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ReservedSpace, must be a value greater than or equal to 0.", new [] { "ReservedSpace" });
            }

            // Zone (int?) minimum
            if(this.Zone < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Zone, must be a value greater than or equal to 1.", new [] { "Zone" });
            }

            // ItemOrientationSearchDepth (int?) maximum
            if(this.ItemOrientationSearchDepth > (int?)10)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ItemOrientationSearchDepth, must be a value less than or equal to 10.", new [] { "ItemOrientationSearchDepth" });
            }

            // ItemOrientationSearchDepth (int?) minimum
            if(this.ItemOrientationSearchDepth < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ItemOrientationSearchDepth, must be a value greater than or equal to 0.", new [] { "ItemOrientationSearchDepth" });
            }

            yield break;
        }
    }

}
