/* 
 * paccurate.io
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.4.4
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// BoxProperties
    /// </summary>
    [DataContract]
    public partial class BoxProperties :  IEquatable<BoxProperties>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="BoxProperties" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected BoxProperties() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="BoxProperties" /> class.
        /// </summary>
        /// <param name="name">name for the type of box..</param>
        /// <param name="refId">box type reference identifier passed backed from request..</param>
        /// <param name="price">Fixed price of the container, in whole units of currency, default USD cents. This can represent the cost of a flat rate carton, the cost of the actual carton materials, or it can include any other flat fees that may need to be added on a &lt;i&gt;per-carton&lt;/i&gt; basis, such as handling, accessorial surchages, oversize fees, etc. This value is &lt;i&gt;added&lt;/i&gt; to any rate table rates defined for the carton..</param>
        /// <param name="weightTare">weight of the container when empty or otherwise unladen, i.e., of the box itself..</param>
        /// <param name="weightMax">maximum allowable gross weight for the box, i.e., all packed item weights plus the weightTare. (required).</param>
        /// <param name="dimensions">the [height,length,width] of the box. (required).</param>
        /// <param name="centerOfMass">the coordinates of the center of mass of the box..</param>
        /// <param name="rateTable">An optional rate table definition for improved carton selection and pricing optimization. Defaults are included using retail rates for FedEx and UPS if carrier and service is provided, but optimization can be improved with more data passed in a carton&#39;s specific rate table. Methods are &lt;ol&gt;&lt;li&gt;Provide carrier, service, and zone.&lt;/li&gt;&lt;li&gt;Provide all acceptable weights and prices to use for the carton, similar to actual carrier rate tables.&lt;/li&gt;&lt;li&gt;Provide the coefficients required for a simple linear weight-dependent pricing model.&lt;/li&gt;&lt;/ol&gt;.</param>
        public BoxProperties(string name = default(string), int? refId = default(int?), int? price = default(int?), decimal? weightTare = default(decimal?), decimal? weightMax = default(decimal?), Object dimensions = default(Object), Object centerOfMass = default(Object), Object rateTable = default(Object))
        {
            // to ensure "weightMax" is required (not null)
            if (weightMax == null)
            {
                throw new InvalidDataException("weightMax is a required property for BoxProperties and cannot be null");
            }
            else
            {
                this.WeightMax = weightMax;
            }
            // to ensure "dimensions" is required (not null)
            if (dimensions == null)
            {
                throw new InvalidDataException("dimensions is a required property for BoxProperties and cannot be null");
            }
            else
            {
                this.Dimensions = dimensions;
            }
            this.Name = name;
            this.RefId = refId;
            this.Price = price;
            this.WeightTare = weightTare;
            this.CenterOfMass = centerOfMass;
            this.RateTable = rateTable;
        }
        
        /// <summary>
        /// name for the type of box.
        /// </summary>
        /// <value>name for the type of box.</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// box type reference identifier passed backed from request.
        /// </summary>
        /// <value>box type reference identifier passed backed from request.</value>
        [DataMember(Name="refId", EmitDefaultValue=false)]
        public int? RefId { get; set; }

        /// <summary>
        /// Fixed price of the container, in whole units of currency, default USD cents. This can represent the cost of a flat rate carton, the cost of the actual carton materials, or it can include any other flat fees that may need to be added on a &lt;i&gt;per-carton&lt;/i&gt; basis, such as handling, accessorial surchages, oversize fees, etc. This value is &lt;i&gt;added&lt;/i&gt; to any rate table rates defined for the carton.
        /// </summary>
        /// <value>Fixed price of the container, in whole units of currency, default USD cents. This can represent the cost of a flat rate carton, the cost of the actual carton materials, or it can include any other flat fees that may need to be added on a &lt;i&gt;per-carton&lt;/i&gt; basis, such as handling, accessorial surchages, oversize fees, etc. This value is &lt;i&gt;added&lt;/i&gt; to any rate table rates defined for the carton.</value>
        [DataMember(Name="price", EmitDefaultValue=false)]
        public int? Price { get; set; }

        /// <summary>
        /// weight of the container when empty or otherwise unladen, i.e., of the box itself.
        /// </summary>
        /// <value>weight of the container when empty or otherwise unladen, i.e., of the box itself.</value>
        [DataMember(Name="weightTare", EmitDefaultValue=false)]
        public decimal? WeightTare { get; set; }

        /// <summary>
        /// maximum allowable gross weight for the box, i.e., all packed item weights plus the weightTare.
        /// </summary>
        /// <value>maximum allowable gross weight for the box, i.e., all packed item weights plus the weightTare.</value>
        [DataMember(Name="weightMax", EmitDefaultValue=false)]
        public decimal? WeightMax { get; set; }

        /// <summary>
        /// the [height,length,width] of the box.
        /// </summary>
        /// <value>the [height,length,width] of the box.</value>
        [DataMember(Name="dimensions", EmitDefaultValue=false)]
        public Object Dimensions { get; set; }

        /// <summary>
        /// the coordinates of the center of mass of the box.
        /// </summary>
        /// <value>the coordinates of the center of mass of the box.</value>
        [DataMember(Name="centerOfMass", EmitDefaultValue=false)]
        public Object CenterOfMass { get; set; }

        /// <summary>
        /// An optional rate table definition for improved carton selection and pricing optimization. Defaults are included using retail rates for FedEx and UPS if carrier and service is provided, but optimization can be improved with more data passed in a carton&#39;s specific rate table. Methods are &lt;ol&gt;&lt;li&gt;Provide carrier, service, and zone.&lt;/li&gt;&lt;li&gt;Provide all acceptable weights and prices to use for the carton, similar to actual carrier rate tables.&lt;/li&gt;&lt;li&gt;Provide the coefficients required for a simple linear weight-dependent pricing model.&lt;/li&gt;&lt;/ol&gt;
        /// </summary>
        /// <value>An optional rate table definition for improved carton selection and pricing optimization. Defaults are included using retail rates for FedEx and UPS if carrier and service is provided, but optimization can be improved with more data passed in a carton&#39;s specific rate table. Methods are &lt;ol&gt;&lt;li&gt;Provide carrier, service, and zone.&lt;/li&gt;&lt;li&gt;Provide all acceptable weights and prices to use for the carton, similar to actual carrier rate tables.&lt;/li&gt;&lt;li&gt;Provide the coefficients required for a simple linear weight-dependent pricing model.&lt;/li&gt;&lt;/ol&gt;</value>
        [DataMember(Name="rateTable", EmitDefaultValue=false)]
        public Object RateTable { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class BoxProperties {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  RefId: ").Append(RefId).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  WeightTare: ").Append(WeightTare).Append("\n");
            sb.Append("  WeightMax: ").Append(WeightMax).Append("\n");
            sb.Append("  Dimensions: ").Append(Dimensions).Append("\n");
            sb.Append("  CenterOfMass: ").Append(CenterOfMass).Append("\n");
            sb.Append("  RateTable: ").Append(RateTable).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as BoxProperties);
        }

        /// <summary>
        /// Returns true if BoxProperties instances are equal
        /// </summary>
        /// <param name="input">Instance of BoxProperties to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(BoxProperties input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.RefId == input.RefId ||
                    (this.RefId != null &&
                    this.RefId.Equals(input.RefId))
                ) && 
                (
                    this.Price == input.Price ||
                    (this.Price != null &&
                    this.Price.Equals(input.Price))
                ) && 
                (
                    this.WeightTare == input.WeightTare ||
                    (this.WeightTare != null &&
                    this.WeightTare.Equals(input.WeightTare))
                ) && 
                (
                    this.WeightMax == input.WeightMax ||
                    (this.WeightMax != null &&
                    this.WeightMax.Equals(input.WeightMax))
                ) && 
                (
                    this.Dimensions == input.Dimensions ||
                    (this.Dimensions != null &&
                    this.Dimensions.Equals(input.Dimensions))
                ) && 
                (
                    this.CenterOfMass == input.CenterOfMass ||
                    (this.CenterOfMass != null &&
                    this.CenterOfMass.Equals(input.CenterOfMass))
                ) && 
                (
                    this.RateTable == input.RateTable ||
                    (this.RateTable != null &&
                    this.RateTable.Equals(input.RateTable))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.RefId != null)
                    hashCode = hashCode * 59 + this.RefId.GetHashCode();
                if (this.Price != null)
                    hashCode = hashCode * 59 + this.Price.GetHashCode();
                if (this.WeightTare != null)
                    hashCode = hashCode * 59 + this.WeightTare.GetHashCode();
                if (this.WeightMax != null)
                    hashCode = hashCode * 59 + this.WeightMax.GetHashCode();
                if (this.Dimensions != null)
                    hashCode = hashCode * 59 + this.Dimensions.GetHashCode();
                if (this.CenterOfMass != null)
                    hashCode = hashCode * 59 + this.CenterOfMass.GetHashCode();
                if (this.RateTable != null)
                    hashCode = hashCode * 59 + this.RateTable.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Price (int?) minimum
            if(this.Price < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Price, must be a value greater than or equal to 0.", new [] { "Price" });
            }

            // WeightTare (decimal?) minimum
            if(this.WeightTare < (decimal?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for WeightTare, must be a value greater than or equal to 0.", new [] { "WeightTare" });
            }

            // WeightMax (decimal?) minimum
            if(this.WeightMax < (decimal?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for WeightMax, must be a value greater than or equal to 0.", new [] { "WeightMax" });
            }

            yield break;
        }
    }

}
